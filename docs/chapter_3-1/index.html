<!doctype html>
<html class="docs-version-current" lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.6">
<link rel="alternate" type="application/rss+xml" href="/refactoring/blog/rss.xml" title="Refactoring 2.0 Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/refactoring/blog/atom.xml" title="Refactoring 2.0 Blog Atom Feed"><title data-react-helmet="true">3장 코드에서 나는 악취 上 | Refactoring 2.0</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://dev-in-book.github.io/refactoring/docs/chapter_3-1"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="3장 코드에서 나는 악취 上 | Refactoring 2.0"><meta data-react-helmet="true" name="description" content="리팩토링을 언제 해야한다고 생각하나?"><meta data-react-helmet="true" property="og:description" content="리팩토링을 언제 해야한다고 생각하나?"><link data-react-helmet="true" rel="shortcut icon" href="/refactoring/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://dev-in-book.github.io/refactoring/docs/chapter_3-1"><link data-react-helmet="true" rel="alternate" href="https://dev-in-book.github.io/refactoring/docs/chapter_3-1" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://dev-in-book.github.io/refactoring/docs/chapter_3-1" hreflang="x-default"><link rel="stylesheet" href="/refactoring/assets/css/styles.192a7394.css">
<link rel="preload" href="/refactoring/assets/js/runtime~main.8799840d.js" as="script">
<link rel="preload" href="/refactoring/assets/js/main.7e1c37ad.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#" class="skipToContent_OuoZ">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/refactoring/"><img src="/refactoring/img/refactoring.jpg" alt="dev-in-book" class="themedImage_TMUO themedImage--light_4Vu1 navbar__logo"><img src="/refactoring/img/refactoring.jpg" alt="dev-in-book" class="themedImage_TMUO themedImage--dark_uzRr navbar__logo"><b class="navbar__title">리팩터링 2.0</b></a><a class="navbar__item navbar__link navbar__link--active" href="/refactoring/docs/chapter_1">📕 리팩터링 완독하기 프로젝트</a><a class="navbar__item navbar__link" href="/refactoring/blog">👨‍👩‍👧‍👦 참여자</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/dev-in-book/refactoring" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>⛳️ GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_wgqa"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="react-toggle toggle_2i4l react-toggle--disabled"><div class="react-toggle-track" role="button" tabindex="-1"><div class="react-toggle-track-check"><span class="toggle_iYfV">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_iYfV">🌞</span></div><div class="react-toggle-thumb"></div></div><input type="checkbox" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docs-wrapper docs-doc-page"><div class="docPage_lDyR"><button class="clean-btn backToTopButton_i9tI" type="button"><svg viewBox="0 0 24 24" width="28"><path d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z" fill="currentColor"></path></svg></button><aside class="docSidebarContainer_0YBq"><div class="sidebar_a3j0"><nav class="menu thin-scrollbar menu_cyFh menuWithAnnouncementBar_+O1J"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" href="/refactoring/docs/chapter_1">1장 리팩터링: 첫 번째 예시</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" href="/refactoring/docs/chapter_2">2장 리팩터링 원칙</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link menu__link--active" aria-current="page" href="/refactoring/docs/chapter_3-1">3장 코드에서 나는 악취 上</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" href="/refactoring/docs/chapter_3-2">3장 코드에서 나는 악취 下</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" href="/refactoring/docs/chapter_4">4장 테스트 구축하기</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" href="/refactoring/docs/chapter_5">5장 리팩터링 카탈로그 보는 법</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" href="/refactoring/docs/chapter_6-1">6장 기본적인 리팩터링 上</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" href="/refactoring/docs/chapter_6-7">6장 기본적인 리팩터링 下</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" href="/refactoring/docs/chapter_10-1">10장 조건부 로직 간소화 上</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" href="/refactoring/docs/chapter_10-2">10장 조건부 로직 간소화 下</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" href="/refactoring/docs/chapter_7">7장 캡슐화</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" href="/refactoring/docs/chapter_8-1">8장 기능 이동 上</a></li></ul></nav></div></aside><main class="docMainContainer_r8cw"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_zHA2"><div class="docItemContainer_oiyr"><article><div class="tocCollapsible_aw-L theme-doc-toc-mobile tocMobile_Tx6Y"><button type="button" class="clean-btn tocCollapsibleButton_zr6a">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>3장 코드에서 나는 악취 上</h1></header><section><span class="title_aw9g">written by</span><div class="authors_D0Uc"><div class="author_wC7X"><a href="https://github.com/guswnl0610" target="_blank" rel="noopener noreferrer" class="avatar__link_Mc9C"><img src="https://github.com/guswnl0610.png" alt="Mengkki" class="avatar__photo_y+NV"></a><div class="avatar__info_oz+C"><span class="bold_xdb6">Mengkki  🏆</span><span>Front End Engineer</span></div></div></div></section><blockquote><p>리팩토링을 언제 해야한다고 생각하나?
코드에서 냄새가 날 때다...!</p></blockquote><p>숙련된 개발자의 감만큼 정확한 기준은 없다. <del>시켜줘...빡숙 개발자</del></p><p>인스턴스 변수는 몇 개가 적당한지, 메서드는 몇줄을 넘어가면 안 좋은지 등은 각자 경험을 통해 감을 키워야 한다.</p><p>우선 이번 챕터를 통해 코드가 풍기는 냄새가 무엇인지 찾고, 해법으로 제시한 리팩터링 기법을 찾아 냄새를 없애는 데 도움이 될 지 생각해보도록 하자</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="31-기이한-이름"></a>3.1 기이한 이름<a class="hash-link" href="#31-기이한-이름" title="Direct link to heading">#</a></h2><p>코드를 명료하게 표현하는 데 가장 중요한 요소 하나는 바로 이름이다. 함수, 모듈, 변수, 클래스 등은 그 이름만 보고도 각각 무슨 일을 하고 어떻게 사용해야 하는지 명확히 알 수 있도록 신경써서 이름을 지어야 한다.</p><p>하지만 이름 짓기는 프로그래밍에서 가장 어려운 두가지 중 하나다. 그 때문에 우리가 가장 많이 사용하는 리팩터링도 <code>함수 선언 바꾸기</code>, <code>변수 이름 바꾸기</code>, <code>필드 이름 바꾸기</code> 처럼 이름을 바꾸는 리팩터링들이다.</p><p>이름 바꾸기는 단순히 이름을 다르게 표현하는 연습이 아니다. 마땅한 이름이 떠오르지 않는다면 설계에 더 근본적인 문제가 숨어 있을 가능성이 높다. 그래서 혼란스러운 이름을 잘 정리하면 코드가 훨씬 간결해질 때가 많다.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="32-중복-코드"></a>3.2 중복 코드<a class="hash-link" href="#32-중복-코드" title="Direct link to heading">#</a></h2><p>똑같은 코드 구조가 여러 곳에서 반복된다면 하나로 통합하여 더 나은 프로그램을 만들 수 있다. 코드가 중복되면 각각을 볼때마다 서로 차이점은 없는지 주의 깊게 살펴봐야 하는 부담이 생긴다.</p><p>한 클래스에서 두 메서드가 똑같은 표현식을 사용하는 경우가 있다. 이럴 때는 <code>함수 추출하기</code> 를 써서 양쪽 모두 추출한 메서드를 호출하게 바꾸면 된다.</p><p>코드가 비슷한데 완전히 똑같지는 않다면, 먼저 <code>문장 슬라이드하기</code> 로 비슷한 부분을 한 곳에 모아 함수 추출하기를 더 쉽게 적용할 수 있는지 살펴본다. 같은 부모로부터 파생된 서브클래스들에 코드가 중복되어 있다면, 각자 따로 호출되지 않도록 <code>메서드 올리기</code>를 적용해 부모로 옮긴다.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="33-긴-함수"></a>3.3 긴 함수<a class="hash-link" href="#33-긴-함수" title="Direct link to heading">#</a></h2><p>선생님들의 오랜 경험에 비추어보았을 때, 오랜 기간 잘 활용되는 프로그램들은 하나같이 짧은 함수들로 구성이 되어 있다.</p><p>Q. 코드 읽는 사람 입장에서는 짧은 함수 여러개로 이루어져 있으면 읽을때 왔다갔다 해야해서 부담스럽지 않나요?</p><p>A. 함수 이름을 잘 지으면 함수의 본문을 읽을 필요가 없어요 ^^</p><p>함수 이름을 잘 짓기 위해서는 훨씬 적극적으로 함수를 쪼개야 한다.</p><p>주석을 달아야 할 만한 부분은 무조건 함수로 만든다. 함수의 이름은 코드의 목적이 잘 드러나게 짓고, 본문에는 주석으로 설명하려는 부분을 담자</p><blockquote><p>💡 &#x27;무엇을 하는지&#x27;를 코드가 잘 설명해주지 못할수록 함수로 만드는 게 유리하다.</p></blockquote><p>함수를 짧게 만드는 작업의 99%는 <code>함수 추출하기</code> 가 차지한다. 본문에서 따로 묶어 빼내면 좋은 코드 덩어리를 찾아 새로운 함수로 만드는 것이다.</p><p>그 덩어리는 어케 찾나요? 일단 이친구들을 의심해보세요!</p><ul><li>주석
한줄의 코드더라도 함수로 추출하는 것이 낫다. 함수 이름은 주석 내용 토대로 짓기!</li><li>조건문
<code>조건문 분쇄하기</code>나, 거대한 switch문은 case마다 <code>함수 추출하기,</code> 같은 조건을 기준으로 나뉘는 switch문이 여러개라면 <code>조건문을 다형성으로 바꾸기</code></li><li>반복문
<code>반복문 쪼개기</code></li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="34-긴-매개변수-목록"></a>3.4 긴 매개변수 목록<a class="hash-link" href="#34-긴-매개변수-목록" title="Direct link to heading">#</a></h2><p>함수가 배개변수로 받는 것들이 많아진다면 그 자체로 이해하기 어려워질 수 있다. 줄여봅시다~</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_y2LR" id="매개변수를-질의-함수로-바꾸기"></a>매개변수를 질의 함수로 바꾸기<a class="hash-link" href="#매개변수를-질의-함수로-바꾸기" title="Direct link to heading">#</a></h3><p>다른 매개변수에서 값을 얻어올 수 있는 매개변수가 있는 경우</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_y2LR" id="객체-통째로-넘기기"></a>객체 통째로 넘기기<a class="hash-link" href="#객체-통째로-넘기기" title="Direct link to heading">#</a></h3><p>어느 데이터 구조에서 값들을 뽑아 각각을 별개의 매개변수로 쓰고 있는 경우</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_y2LR" id="매개변수-객체-만들기"></a>매개변수 객체 만들기<a class="hash-link" href="#매개변수-객체-만들기" title="Direct link to heading">#</a></h3><p>항상 함께 전달되는 매개변수가 있는 경우</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_y2LR" id="플래그-인수-제거하기"></a>플래그 인수 제거하기<a class="hash-link" href="#플래그-인수-제거하기" title="Direct link to heading">#</a></h3><p>함수의 동작 방식을 정하는 플래그 역할의 매개변수가 있는 경우</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_y2LR" id="여러-함수를-클래스로-묶기"></a>여러 함수를 클래스로 묶기<a class="hash-link" href="#여러-함수를-클래스로-묶기" title="Direct link to heading">#</a></h3><p>여러 함수가 특정 매개변수들의 값을 공통으로 사용하는 경우</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="35-전역-데이터"></a>3.5 전역 데이터<a class="hash-link" href="#35-전역-데이터" title="Direct link to heading">#</a></h2><p>이녀석이 뿜는 악취는 우리가 겪을 수 있는 악취 중 가장 지독한 편에 속한다고 한다....</p><p>전역 데이터는 코드베이스 어디서든 건드릴 수 있고 값을 누가 바꿨는지 찾아낼 매커니즘이 없다는 게 문제다.</p><p>전역 데이터의 대표적인 형태는 전역 변수지만 클래스 변수와 싱클톤에서도 같은 문제가 발생할 수 있다.</p><p>이를 방지하기 위해 우리가 사용하는 가장 대표적인 리팩터링은 <code>변수 캡슐화하기</code> 다. 다른 코드에서 오염시킬 가능성이 있는 데이터를 발견할 때마다 이 기법을 가장 먼저 적용한다.</p><p>이런 데이터는 함수로 감싸는 것 만으로도 데이터를 수정하는 부분을 쉽게 찾을 수 있고 접근을 통제할 수 있게 된다.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="36-가변-데이터"></a>3.6 가변 데이터<a class="hash-link" href="#36-가변-데이터" title="Direct link to heading">#</a></h2><p>mutable data 라는 영제에서 유추해낼 수 있듯이...유남생? 이녀석도 냄새가 고약하다.</p><p>가변 데이터의 유효범위가 단 몇 줄이라면 가변 데이터라 해도 문제를 일으킬 일이 별로 없다. 하지만 나중에 유효범위가 넓어질 수 있고, 그러면 위험도 덩달아 커진다.</p><p>하지만... 무분별한 데이터 수정에 따른 위험을 줄이는 방법은 얼마든지 있다!</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_y2LR" id="변수-캡슐화하기"></a>변수 캡슐화하기<a class="hash-link" href="#변수-캡슐화하기" title="Direct link to heading">#</a></h3><p>정해놓은 함수를 거쳐야만 값을 수정할 수 있도록 한다. 값이 어떻게 수정되는지 감시하거나 코드를 개선하기 쉽다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_y2LR" id="변수-쪼개기"></a>변수 쪼개기<a class="hash-link" href="#변수-쪼개기" title="Direct link to heading">#</a></h3><p>하나의 변수에 용도가 다른 값들을 저장하느라 값을 갱신하는 경우라면 이것을! 용도별로 독립 변수에 저장하게 하여 값 갱신이 문제를 일으킬 여지를 없앤다</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_y2LR" id="문장-슬라이드-하기-함수-추출하기"></a>문장 슬라이드 하기, 함수 추출하기<a class="hash-link" href="#문장-슬라이드-하기-함수-추출하기" title="Direct link to heading">#</a></h3><p>갱신 로직은 다른 코드와 떨어뜨려놓는 것이 좋다. 무언가를 갱신하는 코드로부터 부작용이 없는 코드를 분리한다</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_y2LR" id="질의-함수와-변경-함수-분리하기"></a>질의 함수와 변경 함수 분리하기<a class="hash-link" href="#질의-함수와-변경-함수-분리하기" title="Direct link to heading">#</a></h3><p>API를 만들때는 이것을 활용해 꼭 필요한 경우가 아니라면 부작용이 있는 코드를 호출할 수 없게 한다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_y2LR" id="세터-제거하기"></a>세터 제거하기<a class="hash-link" href="#세터-제거하기" title="Direct link to heading">#</a></h3><p>간혹 세터를 호출하는 클라이언트를 찾는 것만으로도 변수의 유효범위를 줄이는 데 도움될 때가 있다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_y2LR" id="여러-함수를-클래스로-묶기-여러-함수를-변환-함수로-묶기"></a>여러 함수를 클래스로 묶기, 여러 함수를 변환 함수로 묶기<a class="hash-link" href="#여러-함수를-클래스로-묶기-여러-함수를-변환-함수로-묶기" title="Direct link to heading">#</a></h3><p>변수를 갱신하는 코드들의 유효범위를 클래스 내부로 제한한다.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="37-뒤엉킨-변경"></a>3.7 뒤엉킨 변경<a class="hash-link" href="#37-뒤엉킨-변경" title="Direct link to heading">#</a></h2><p>우리는 코드를 수정할 때는 시스템에서 고쳐야 할 딱 한군데를 찾아서 그부분만 수정할 수 있기를 바란다.</p><p>만약 그렇게 할 수 없다면... 냄새가 나는거다. 뒤엉킨 변경과 <a href="/refactoring/docs/chapter_3-1#38-산탄총-수술">산탄총 수술</a> 의 냄새가...</p><p>뒤엉킨 변경은 단일 책임 원칙(SRP)이 제대로 지켜지지 않을 때 나타난다. 예를들면</p><p>DB가 추가될 때마다 함수 3개를 바꿔야 하고, 금융상품이 추가될때마다 또다른 함수 4개를 바꿔야 하는 모듈이 있다면 뒤엉킨 변경이 발생했다는 뜻이다!</p><p>DB와 금융 상품은 다른 맥락에서 이뤄지므로 다른 모듈로 분리해야 편하다.</p><p>개발 초기에는 맥락 간의 경계를 나누기 어렵고 기능이 변경되면서 경계도 끊임없이 움직이기 때문에 나중에서야 이 악취를 느끼는 경우도 많다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_y2LR" id="단계-쪼개기"></a>단계 쪼개기<a class="hash-link" href="#단계-쪼개기" title="Direct link to heading">#</a></h3><p>DB에서 데이터를 가져와서 금융 로직을 처리해야 하는 일처럼 순차적으로 실행되는 게 자연스러운 맥락이라면, 다음 맥락에 필요한 데이터를 특정한 데이터 구조에 담아 전달하게 하는 식으로 단계를 분리하자</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_y2LR" id="함수-옮기기"></a>함수 옮기기<a class="hash-link" href="#함수-옮기기" title="Direct link to heading">#</a></h3><p>전체 처리 과정 곳곳에서 각기 다른 맥락의 함수를 호출하는 빈도가 높다면, 각 맥락에 해당하는 적당한 모듈을 만들어서 관련 함수들을 모은다. 그러면 처리 과정이 맥락별로 구분된다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_y2LR" id="함수-추출하기"></a>함수 추출하기<a class="hash-link" href="#함수-추출하기" title="Direct link to heading">#</a></h3><p>여러 맥락의 일에 관여하는 함수가 있다면 함수 옮기기를 하기 전에 함수 추출하기부터 수행한다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_y2LR" id="클래스-추출하기"></a>클래스 추출하기<a class="hash-link" href="#클래스-추출하기" title="Direct link to heading">#</a></h3><p>모듈이 클래스라면 클래스 추출하기가 맥락별 분리 방법을 잘 안내해줄 거래요...</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="38-산탄총-수술"></a>3.8 산탄총 수술<a class="hash-link" href="#38-산탄총-수술" title="Direct link to heading">#</a></h2><p>산탄총 수술은 뒤엉킨 변경과 비슷하면서 정반대다</p><p>이 냄새는 코드를 변경할 때마다 자잘하게 수정해야 하는 클래스가 많을 때 풍긴다.</p><p>변경할 부분이 코드 전반에 퍼져 있다면 찾기도 어렵고 꼭 수정해야 할 곳을 지나치기 쉽다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_y2LR" id="함수-옮기기-필드-옮기기"></a>함수 옮기기, 필드 옮기기<a class="hash-link" href="#함수-옮기기-필드-옮기기" title="Direct link to heading">#</a></h3><p>함께 변경되는 대상들을 모두 한 모듈에 묶어둔다</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_y2LR" id="여러-함수를-클래스로-묶기-1"></a>여러 함수를 클래스로 묶기<a class="hash-link" href="#여러-함수를-클래스로-묶기-1" title="Direct link to heading">#</a></h3><p>비슷한 데이터를 다루는 함수가 많다면 이걸 적용하자</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_y2LR" id="여러-함수를-변환-함수로-묶기"></a>여러 함수를 변환 함수로 묶기<a class="hash-link" href="#여러-함수를-변환-함수로-묶기" title="Direct link to heading">#</a></h3><p>데이터 구조를 변환하거나 보강하는 함수들에는 이걸 적용한다</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_y2LR" id="단계-쪼개기-1"></a>단계 쪼개기<a class="hash-link" href="#단계-쪼개기-1" title="Direct link to heading">#</a></h3><p>이렇게 묶은 함수들의 출력 결과를 묶어서 다음 단계의 로직으로 전달할 수 있다면 이걸 적용한다</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="39-기능-편애"></a>3.9 기능 편애<a class="hash-link" href="#39-기능-편애" title="Direct link to heading">#</a></h2><p>프로그램을 모듈화할 때는 코드를 여러 영역으로 나눈 뒤 한 영역 내에서 이뤄지는 상호작용은 최대로, 영역 간 상호작용은 최소로 줄이는 데 주력한다.</p><p>기능 편애는 어떤 함수가 자기가 속한 모듈의 함수나 데이터보다 다른 모듈의 함수와 데이터와 상호작용을 더 많이 할 때 풍긴다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_y2LR" id="함수-옮기기-1"></a>함수 옮기기<a class="hash-link" href="#함수-옮기기-1" title="Direct link to heading">#</a></h3><p>우리 함수가 저 모듈과 더 친하게 지내하고 싶어하는 것 같으니 그쪽으로 보내주자... 그 함수의 일부에서만 기능을 편애한다면 그부분만 독립 함수로 떼어낸 다음에 보내주자</p><p>하지만 이런 기능 편애를 부추기는 디자인 패턴들도 있다</p><p>디자인 패턴 중 <code>전략 패턴</code> , <code>방문자 패턴</code>, <code>자기 위임</code> 등도 뒤엉킨 변경 냄새를 없앨 때 활용하는 패턴인데, 이들의 기본이 되는 원칙은 함께 변경할 대상을 한데 모으는 것이다.</p><p>이런 패턴들을 적용하면 오버라이드 해야 할 소량의 동작 코드를 각각의 클래스로 격리해주므로 수정하기 쉬워지지만 간접 호출이 늘어난다</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="310-데이터-뭉치"></a>3.10 데이터 뭉치<a class="hash-link" href="#310-데이터-뭉치" title="Direct link to heading">#</a></h2><p>데이터 항목 서너 개가 여러 곳에서 항상 뭉쳐 다니는 모습을 볼 수 있다. 이렇게 몰려다니는 데이터 뭉치는 보금자리를 따로 마련해줘야 한다.</p><p>데이터 뭉치인지 판별하려면 값 하나를 삭제했을 때 나머지 데이터만으로는 의미가 없다면 객체로 환생하길 갈망하는 데이터 뭉치라는 뜻이다!</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_y2LR" id="클래스-추출하기-1"></a>클래스 추출하기<a class="hash-link" href="#클래스-추출하기-1" title="Direct link to heading">#</a></h3><p>우선 필드 형태의 데이터 뭉치를 찾아서 클래스 추출하기로 하나의 객체로 묶는다.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_y2LR" id="매개변수-객체-만들기-객체-통째로-넘기기"></a>매개변수 객체 만들기, 객체 통째로 넘기기<a class="hash-link" href="#매개변수-객체-만들기-객체-통째로-넘기기" title="Direct link to heading">#</a></h3><p>메서드 시그니처에 있는 데이터 뭉치는 매게변수는 이 방법들을 적용해서 매개변수 수를 줄인다. 메서드 호출 코드가 간결해질 것이다.</p><p>기능 편애를 없애는 과정에서 새로운 클래스를 만들었다면, 이어서 그 클래스로 옮기면 좋을 동작은 없는지 살펴보자.</p><p>이런 연계 과정은 상당한 중복을 없애고 향후 개발을 가속하는 유용한 클래스를 탄생시키는 결과를 낳는다.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="311-기본형-집착"></a>3.11 기본형 집착<a class="hash-link" href="#311-기본형-집착" title="Direct link to heading">#</a></h2><p>금액이나 전화번호같은 데이터를 단순히 number, string으로 표현하지 말자. 냄새난다!</p><p><code>기본형을 객체로 바꾸기</code>를 적용해서 우가우가 기본형 자료형을 최신코드로 바꿀수있다.</p><p>기본형으로 표현된 코드가 조건부 동작을 제어하는 타입 코드로 쓰였다면 <code>타입 코드를 서브클래스로 바꾸기</code> 와 <code>조건부 로직을 다형성으로 바꾸기</code> 를 차례대로 적용하자.</p><p>자주 몰려다니는 기본형 그룹도 데이터 뭉치다. 따라서 <code>클래스 추출하기</code>와 <code>매개변수 객체 만들기</code>를 이용해서 문명으로 이끌어줘야 한다</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_y2LR" id="312-반복되는-switch문"></a>3.12 반복되는 switch문<a class="hash-link" href="#312-반복되는-switch문" title="Direct link to heading">#</a></h2><p>중복된 switch문이 문제가 되는 이유는 조건절을 하나 추가할 때마다 다른 switch문들도 모두 찾아서 수정해주어야 하기 때문이다.</p><p>이럴 때 <code>조건부 로직을 다형성으로 바꾸기</code>는 반복된 switch문이 내뿜는 사악한 기운을 제압하여 코드베이스를 최신 스타일로 바꿔주는 세련된 무기인 셈이다.</p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.dev/dev-in-book/refactoring/blob/main/docs/03_chapter_3-1.mdx" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_mS5F" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_mt2f"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/refactoring/docs/chapter_2"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« 2장 리팩터링 원칙</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/refactoring/docs/chapter_3-2"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">3장 코드에서 나는 악취 下 »</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_vrFS thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#31-기이한-이름" class="table-of-contents__link">3.1 기이한 이름</a></li><li><a href="#32-중복-코드" class="table-of-contents__link">3.2 중복 코드</a></li><li><a href="#33-긴-함수" class="table-of-contents__link">3.3 긴 함수</a></li><li><a href="#34-긴-매개변수-목록" class="table-of-contents__link">3.4 긴 매개변수 목록</a><ul><li><a href="#매개변수를-질의-함수로-바꾸기" class="table-of-contents__link">매개변수를 질의 함수로 바꾸기</a></li><li><a href="#객체-통째로-넘기기" class="table-of-contents__link">객체 통째로 넘기기</a></li><li><a href="#매개변수-객체-만들기" class="table-of-contents__link">매개변수 객체 만들기</a></li><li><a href="#플래그-인수-제거하기" class="table-of-contents__link">플래그 인수 제거하기</a></li><li><a href="#여러-함수를-클래스로-묶기" class="table-of-contents__link">여러 함수를 클래스로 묶기</a></li></ul></li><li><a href="#35-전역-데이터" class="table-of-contents__link">3.5 전역 데이터</a></li><li><a href="#36-가변-데이터" class="table-of-contents__link">3.6 가변 데이터</a><ul><li><a href="#변수-캡슐화하기" class="table-of-contents__link">변수 캡슐화하기</a></li><li><a href="#변수-쪼개기" class="table-of-contents__link">변수 쪼개기</a></li><li><a href="#문장-슬라이드-하기-함수-추출하기" class="table-of-contents__link">문장 슬라이드 하기, 함수 추출하기</a></li><li><a href="#질의-함수와-변경-함수-분리하기" class="table-of-contents__link">질의 함수와 변경 함수 분리하기</a></li><li><a href="#세터-제거하기" class="table-of-contents__link">세터 제거하기</a></li><li><a href="#여러-함수를-클래스로-묶기-여러-함수를-변환-함수로-묶기" class="table-of-contents__link">여러 함수를 클래스로 묶기, 여러 함수를 변환 함수로 묶기</a></li></ul></li><li><a href="#37-뒤엉킨-변경" class="table-of-contents__link">3.7 뒤엉킨 변경</a><ul><li><a href="#단계-쪼개기" class="table-of-contents__link">단계 쪼개기</a></li><li><a href="#함수-옮기기" class="table-of-contents__link">함수 옮기기</a></li><li><a href="#함수-추출하기" class="table-of-contents__link">함수 추출하기</a></li><li><a href="#클래스-추출하기" class="table-of-contents__link">클래스 추출하기</a></li></ul></li><li><a href="#38-산탄총-수술" class="table-of-contents__link">3.8 산탄총 수술</a><ul><li><a href="#함수-옮기기-필드-옮기기" class="table-of-contents__link">함수 옮기기, 필드 옮기기</a></li><li><a href="#여러-함수를-클래스로-묶기-1" class="table-of-contents__link">여러 함수를 클래스로 묶기</a></li><li><a href="#여러-함수를-변환-함수로-묶기" class="table-of-contents__link">여러 함수를 변환 함수로 묶기</a></li><li><a href="#단계-쪼개기-1" class="table-of-contents__link">단계 쪼개기</a></li></ul></li><li><a href="#39-기능-편애" class="table-of-contents__link">3.9 기능 편애</a><ul><li><a href="#함수-옮기기-1" class="table-of-contents__link">함수 옮기기</a></li></ul></li><li><a href="#310-데이터-뭉치" class="table-of-contents__link">3.10 데이터 뭉치</a><ul><li><a href="#클래스-추출하기-1" class="table-of-contents__link">클래스 추출하기</a></li><li><a href="#매개변수-객체-만들기-객체-통째로-넘기기" class="table-of-contents__link">매개변수 객체 만들기, 객체 통째로 넘기기</a></li></ul></li><li><a href="#311-기본형-집착" class="table-of-contents__link">3.11 기본형 집착</a></li><li><a href="#312-반복되는-switch문" class="table-of-contents__link">3.12 반복되는 switch문</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/refactoring/docs/chapter_1">Refactoring 2.0</a></li><li class="footer__item"><a class="footer__link-item" href="/refactoring/blog/member">Member</a></li><li class="footer__item"><a href="https://github.com/dev-in-book/refactoring" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_wgqa"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2022 Dev in Book, Built with Docusaurus.</div></div></div></footer></div>
<script src="/refactoring/assets/js/runtime~main.8799840d.js"></script>
<script src="/refactoring/assets/js/main.7e1c37ad.js"></script>
</body>
</html>